<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>わかば地球儀 フィギュア版</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #222; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ライト
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 10, 10);
scene.add(light);

// 地球テクスチャ
const loader = new THREE.TextureLoader();
const colorMap = loader.load("colormap_final.jpg");
const heightMap = loader.load("heightmap_final.png");

// 地球モデル
const geometry = new THREE.SphereGeometry(5, 128, 128);
const material = new THREE.MeshStandardMaterial({
  map: colorMap,
  displacementMap: heightMap,
  displacementScale: 0.36  // ★ 高低差3倍
});
const globe = new THREE.Mesh(geometry, material);
scene.add(globe);

// カメラ初期位置
camera.position.z = 15;
let targetZoom = 15;
let currentZoom = 15;

// 地球操作
let isDragging = false;
let prevMouse = { x: 0, y: 0 };
renderer.domElement.addEventListener("mousedown", e => { isDragging = e.button === 0; });
renderer.domElement.addEventListener("mouseup", () => { isDragging = false; });
renderer.domElement.addEventListener("mousemove", e => {
  if (isDragging) {
    const dx = e.offsetX - prevMouse.x;
    const dy = e.offsetY - prevMouse.y;
    globe.rotation.y += dx * 0.005;
    globe.rotation.x += dy * 0.005;
  }
  prevMouse = { x: e.offsetX, y: e.offsetY };
});
renderer.domElement.addEventListener("wheel", e => {
  e.preventDefault();
  targetZoom += e.deltaY * 0.01;
  targetZoom = Math.max(7, Math.min(30, targetZoom));
});

// 緯度経度 → 座標
function latLonToVec3(lat, lon, radius = 5.01) {
  const phi = (90 - lat) * Math.PI / 180;
  const theta = (lon + 180) * Math.PI / 180;
  return new THREE.Vector3(
    radius * Math.sin(phi) * Math.cos(theta),
    radius * Math.cos(phi),
    radius * Math.sin(phi) * Math.sin(theta)
  );
}

// フィギュアの配置定義
const figures = [
  { lat: 29.98, lon: 31.13, type: "box" },
  { lat: 34.84, lon: 134.69, type: "box" },
  { lat: 35.02, lon: 135.75, type: "cylinder" },
  { lat: 40.68, lon: 117.23, type: "box" },
  { lat: 48.85, lon: 2.35, type: "cylinder" },
  { lat: 23.13, lon: -82.38, type: "cone" },
  { lat: 27.17, lon: 78.04, type: "box" },
  { lat: 41.89, lon: 12.49, type: "box" },
  { lat: 30.33, lon: 35.44, type: "box" },
  { lat: 43.07, lon: 141.35, type: "cylinder" },
  { lat: 31.23, lon: 121.47, type: "cylinder" },
  { lat: 37.98, lon: 23.72, type: "box" },
  { lat: 52.52, lon: 13.40, type: "cylinder" },
  { lat: 35.68, lon: 139.69, type: "cylinder" },
  { lat: 39.90, lon: 116.40, type: "cylinder" },
  { lat: 25.03, lon: 121.56, type: "cone" },
  { lat: 33.44, lon: -112.07, type: "cone" },
  { lat: -22.90, lon: -43.20, type: "cylinder" },
  { lat: 51.50, lon: -0.12, type: "cylinder" },
  { lat: -33.87, lon: 151.21, type: "cone" },
  { lat: -34.61, lon: -58.38, type: "cylinder" },
  { lat: 60.17, lon: 24.94, type: "cone" },
  { lat: 50.08, lon: 14.43, type: "cone" },
  { lat: 41.39, lon: 2.17, type: "cone" },
  { lat: 30.59, lon: 114.30, type: "cone" }
];

// 各フィギュアの表示
figures.forEach((f, i) => {
  let mesh;
  const pos = latLonToVec3(f.lat, f.lon);

  if (f.type === "box") {
    const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    const mat = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
    mesh = new THREE.Mesh(geo, mat);
  } else if (f.type === "cylinder") {
    const geo = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 16);
    const mat = new THREE.MeshStandardMaterial({ color: 0x00ccff });
    mesh = new THREE.Mesh(geo, mat);
  } else {
    const geo = new THREE.ConeGeometry(0.12, 0.3, 4);
    const mat = new THREE.MeshStandardMaterial({ color: 0xff6699 });
    mesh = new THREE.Mesh(geo, mat);
  }

  mesh.position.copy(pos);
  mesh.lookAt(new THREE.Vector3(0, 0, 0));
  globe.add(mesh);
});

// アニメーション
function animate() {
  requestAnimationFrame(animate);
  currentZoom += (targetZoom - currentZoom) * 0.05;
  camera.position.z = currentZoom;
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
